{"version":3,"file":"useStyles.js","sourceRoot":"","sources":["../../../src/hooks/useStyles.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAC;AAC1C,OAAO,EAAE,2BAA2B,EAAE,MAAM,KAAK,CAAC;AAMlD,MAAM,WAAW,GAAG,CAAC,EAAM,EAAE,MAAU,EAAE,EAAE;IACzC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QACvB,OAAO;KACR;IACD,mEAAmE;IACnE,0CAA0C;IAC1C,sDAAsD;IACtD,oEAAoE;IACpE,YAAY;IACZ,IAAI,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,EAAE;QAClE,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,qBAAqB,CAC/C,MAAM,CAAC,GAAG,CAAC,CAAC,CAAK,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,EAChC,EAAE,CAAC,SAAS,CACb,CAAC;KACH;SAAM,IAAI,2BAA2B,EAAE;QACtC,EAAE,CAAC,UAAU,CAAC,kBAAkB,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAK,EAAE,EAAE,CACtD,CAAC,YAAY,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAC9C,CAAC;KACH;SAAM;QACL,MAAM,CAAC,OAAO,CAAC,CAAC,CAAK,EAAE,EAAE;YACvB,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAC9C,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,OAAO,CAAC;YAC9B,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QACnC,CAAC,CAAC,CAAC;KACJ;AACH,CAAC,CAAC;AAEF,MAAM,UAAU,SAAS,CAAC,EAAM,EAAE,MAAU;IAC1C;;;;;;;;OAQG;IAEH,eAAe,CAAC,GAAG,EAAE;QACnB,WAAW,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;IAC1B,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;AACf,CAAC","sourcesContent":["import { useLayoutEffect } from 'haunted';\r\nimport { supportsAdoptingStyleSheets } from 'lit';\r\n\r\ndeclare const window: Window & {\r\n    ShadyCSS: any;\r\n  };\r\n\r\nconst adoptStyles = (el:any, styles:any) => {\r\n  if (styles.length === 0) {\r\n    return;\r\n  }\r\n  // There are three separate cases here based on Shadow DOM support.\r\n  // (1) shadowRoot polyfilled: use ShadyCSS\r\n  // (2) shadowRoot.adoptedStyleSheets available: use it\r\n  // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\r\n  // rendering\r\n  if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\r\n    window.ShadyCSS.ScopingShim.prepareAdoptedCssText(\r\n      styles.map((s:any) => s.cssText),\r\n      el.localName\r\n    );\r\n  } else if (supportsAdoptingStyleSheets) {\r\n    el.shadowRoot.adoptedStyleSheets = styles.map((s:any) =>\r\n      s instanceof CSSStyleSheet ? s : s.styleSheet\r\n    );\r\n  } else {\r\n    styles.forEach((s:any) => {\r\n      const style = document.createElement('style');\r\n      style.textContent = s.cssText;\r\n      el.shadowRoot.appendChild(style);\r\n    });\r\n  }\r\n};\r\n\r\nexport function useStyles(el:any, styles:any) {\r\n  /**\r\n   * Applies styling to the element shadowRoot using the [[`styles`]]\r\n   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\r\n   * available and will fallback otherwise. When Shadow DOM is polyfilled,\r\n   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\r\n   * is available but `adoptedStyleSheets` is not, styles are appended to the\r\n   * end of the `shadowRoot` to [mimic spec\r\n   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\r\n   */\r\n\r\n  useLayoutEffect(() => {\r\n    adoptStyles(el, styles);\r\n  }, [styles]);\r\n}\r\n"]}